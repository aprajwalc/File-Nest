// Generated by CoffeeScript 1.12.7

/*
CoffeeLint

Copyright (c) 2011 Matthew Perpick.
CoffeeLint is freely distributable under the MIT license.
 */

(function() {
  var CSVReporter, CoffeeScript, ErrorReport, JSLintReporter, Reporter, coffeelint, config, data, errorReport, existsFn, findCoffeeScripts, fs, glob, lintFiles, lintSource, optimist, options, path, paths, read, ref, reportAndExit, scripts, stdin, thisdir,
    slice = [].slice,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  path = require("path");

  fs = require("fs");

  glob = require("glob");

  optimist = require("optimist");

  thisdir = path.dirname(fs.realpathSync(__filename));

  coffeelint = require(path.join(thisdir, "..", "lib", "coffeelint"));

  CoffeeScript = require('coffee-script');

  read = function(path) {
    var realPath;
    realPath = fs.realpathSync(path);
    return fs.readFileSync(realPath).toString();
  };

  findCoffeeScripts = function(paths) {
    var files, i, len, p;
    files = [];
    for (i = 0, len = paths.length; i < len; i++) {
      p = paths[i];
      if (fs.statSync(p).isDirectory()) {
        files = files.concat(glob.sync(p + "/**/*.coffee"));
      } else {
        files.push(p);
      }
    }
    return files;
  };

  ErrorReport = (function() {
    function ErrorReport() {
      this.paths = {};
    }

    ErrorReport.prototype.getExitCode = function() {
      for (path in this.paths) {
        if (this.pathHasError(path)) {
          return 1;
        }
      }
      return 0;
    };

    ErrorReport.prototype.getSummary = function() {
      var error, errorCount, errors, i, len, pathCount, ref, warningCount;
      pathCount = errorCount = warningCount = 0;
      ref = this.paths;
      for (path in ref) {
        errors = ref[path];
        pathCount++;
        for (i = 0, len = errors.length; i < len; i++) {
          error = errors[i];
          if (error.level === 'error') {
            errorCount++;
          }
          if (error.level === 'warn') {
            warningCount++;
          }
        }
      }
      return {
        errorCount: errorCount,
        warningCount: warningCount,
        pathCount: pathCount
      };
    };

    ErrorReport.prototype.getErrors = function(path) {
      return this.paths[path];
    };

    ErrorReport.prototype.pathHasWarning = function(path) {
      return this._hasLevel(path, 'warn');
    };

    ErrorReport.prototype.pathHasError = function(path) {
      return this._hasLevel(path, 'error');
    };

    ErrorReport.prototype.hasError = function() {
      for (path in this.paths) {
        if (this.pathHasError(path)) {
          return true;
        }
      }
      return false;
    };

    ErrorReport.prototype._hasLevel = function(path, level) {
      var error, i, len, ref;
      ref = this.paths[path];
      for (i = 0, len = ref.length; i < len; i++) {
        error = ref[i];
        if (error.level === level) {
          return true;
        }
      }
      return false;
    };

    return ErrorReport;

  })();

  Reporter = (function() {
    function Reporter(errorReport, colorize) {
      if (colorize == null) {
        colorize = true;
      }
      this.errorReport = errorReport;
      this.colorize = colorize && process.stdout.isTTY;
      this.ok = '✓';
      this.warn = '⚡';
      this.err = '✗';
    }

    Reporter.prototype.stylize = function() {
      var map, message, styles;
      message = arguments[0], styles = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (!this.colorize) {
        return message;
      }
      map = {
        bold: [1, 22],
        yellow: [33, 39],
        green: [32, 39],
        red: [31, 39]
      };
      return styles.reduce(function(m, s) {
        return "\u001b[" + map[s][0] + "m" + m + "\u001b[" + map[s][1] + "m";
      }, message);
    };

    Reporter.prototype.publish = function() {
      var errors, paths, report;
      paths = this.errorReport.paths;
      report = "";
      for (path in paths) {
        errors = paths[path];
        report += this.reportPath(path, errors);
      }
      report += this.reportSummary(this.errorReport.getSummary());
      report += "";
      if (!options.argv.q || this.errorReport.hasError()) {
        this.print(report);
      }
      return this;
    };

    Reporter.prototype.reportSummary = function(s) {
      var e, err, file, msg, p, start, w, warn;
      start = s.errorCount > 0 ? this.err + " " + (this.stylize("Lint!", 'red', 'bold')) : s.warningCount > 0 ? this.warn + " " + (this.stylize("Warning!", 'yellow', 'bold')) : this.ok + " " + (this.stylize("Ok!", 'green', 'bold'));
      e = s.errorCount;
      w = s.warningCount;
      p = s.pathCount;
      err = this.plural('error', e);
      warn = this.plural('warning', w);
      file = this.plural('file', p);
      msg = start + " » " + e + " " + err + " and " + w + " " + warn + " in " + p + " " + file;
      return "\n" + this.stylize(msg) + "\n";
    };

    Reporter.prototype.reportPath = function(path, errors) {
      var color, e, hasError, hasWarning, i, len, lineEnd, o, output, overall, pathReport, ref;
      ref = (hasError = this.errorReport.pathHasError(path)) ? [this.err, 'red'] : (hasWarning = this.errorReport.pathHasWarning(path)) ? [this.warn, 'yellow'] : [this.ok, 'green'], overall = ref[0], color = ref[1];
      pathReport = "";
      if (!options.argv.q || hasError) {
        pathReport += "  " + overall + " " + (this.stylize(path, color, 'bold')) + "\n";
      }
      for (i = 0, len = errors.length; i < len; i++) {
        e = errors[i];
        if (options.argv.q && e.level !== 'error') {
          continue;
        }
        o = e.level === 'error' ? this.err : this.warn;
        lineEnd = "";
        if (e.lineNumberEnd != null) {
          lineEnd = "-" + e.lineNumberEnd;
        }
        output = "#" + e.lineNumber + lineEnd;
        pathReport += "     " + (o + " " + (this.stylize(output, color)) + ": " + e.message + ".");
        if (e.context) {
          pathReport += " " + e.context + ".";
        }
        pathReport += "\n";
      }
      return pathReport;
    };

    Reporter.prototype.print = function(message) {
      return console.log(message);
    };

    Reporter.prototype.plural = function(str, count) {
      if (count === 1) {
        return str;
      } else {
        return str + "s";
      }
    };

    return Reporter;

  })();

  CSVReporter = (function(superClass) {
    extend(CSVReporter, superClass);

    function CSVReporter() {
      return CSVReporter.__super__.constructor.apply(this, arguments);
    }

    CSVReporter.prototype.publish = function() {
      var e, errors, f, header, ref, results;
      header = ["path", "lineNumber", "lineNumberEnd", "level", "message"];
      this.print(header.join(","));
      ref = this.errorReport.paths;
      results = [];
      for (path in ref) {
        errors = ref[path];
        results.push((function() {
          var i, len, ref1, results1;
          results1 = [];
          for (i = 0, len = errors.length; i < len; i++) {
            e = errors[i];
            f = [path, e.lineNumber, (ref1 = e.lineNumberEnd) != null ? ref1 : e.lineNumberEnd, e.level, e.message];
            results1.push(this.print(f.join(",")));
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    return CSVReporter;

  })(Reporter);

  JSLintReporter = (function(superClass) {
    extend(JSLintReporter, superClass);

    function JSLintReporter() {
      return JSLintReporter.__super__.constructor.apply(this, arguments);
    }

    JSLintReporter.prototype.publish = function() {
      var e, errors, i, len, ref, ref1;
      this.print("<?xml version=\"1.0\" encoding=\"utf-8\"?><jslint>");
      ref = this.errorReport.paths;
      for (path in ref) {
        errors = ref[path];
        if (errors.length) {
          this.print("<file name=\"" + path + "\">");
          for (i = 0, len = errors.length; i < len; i++) {
            e = errors[i];
            this.print("<issue line=\"" + e.lineNumber + "\"\n        lineEnd=" + ((ref1 = e.lineNumberEnd) != null ? ref1 : e.lineNumberEnd) + "\n        reason=\"[" + (this.escape(e.level)) + "] " + (this.escape(e.message)) + "\"\n        evidence=\"" + (this.escape(e.context)) + "\"/>");
          }
          this.print("</file>");
        }
      }
      return this.print("</jslint>");
    };

    JSLintReporter.prototype.escape = function(msg) {
      var i, len, r, replacements;
      msg = "" + msg;
      if (!msg) {
        return;
      }
      replacements = [[/&/g, "&amp;"], [/"/g, "&quot;"], [/</g, "&lt;"], [/>/g, "&gt;"], [/'/g, "&apos;"]];
      for (i = 0, len = replacements.length; i < len; i++) {
        r = replacements[i];
        msg = msg.replace(r[0], r[1]);
      }
      return msg;
    };

    return JSLintReporter;

  })(Reporter);

  lintFiles = function(paths, config) {
    var errorReport, i, len, literate, source;
    errorReport = new ErrorReport();
    for (i = 0, len = paths.length; i < len; i++) {
      path = paths[i];
      source = read(path);
      literate = CoffeeScript.helpers.isLiterate(path);
      errorReport.paths[path] = coffeelint.lint(source, config, literate);
    }
    return errorReport;
  };

  lintSource = function(source, config, literate) {
    var errorReport;
    if (literate == null) {
      literate = false;
    }
    errorReport = new ErrorReport();
    errorReport.paths["stdin"] = coffeelint.lint(source, config, literate);
    return errorReport;
  };

  reportAndExit = function(errorReport, options) {
    var colorize, reporter;
    reporter = options.argv.jslint ? new JSLintReporter(errorReport) : options.argv.csv ? new CSVReporter(errorReport) : (colorize = !options.argv.nocolor, new Reporter(errorReport, colorize));
    reporter.publish();
    return process.on('exit', function() {
      return process.exit(errorReport.getExitCode());
    });
  };

  options = optimist.usage("Usage: coffeelint [options] source [...]").alias("f", "file").alias("h", "help").alias("v", "version").alias("s", "stdin").alias("q", "quiet").describe("f", "Specify a custom configuration file.").describe("makeconfig", "Prints a default config file").describe("noconfig", "Ignores the environment variable COFFEELINT_CONFIG.").describe("h", "Print help information.").describe("v", "Print current version number.").describe("r", "Recursively lint .coffee files in subdirectories.").describe("csv", "Use the csv reporter.").describe("jslint", "Use the JSLint XML reporter.").describe("nocolor", "Don't colorize the output").describe("s", "Lint the source from stdin").describe("q", "Only print errors.").describe("literate", "Used with --stdin to process as Literate CoffeeScript").boolean("csv").boolean("jslint").boolean("nocolor").boolean("noconfig").boolean("makeconfig").boolean("literate").boolean("r").boolean("s").boolean("q", "Print errors only.");

  if (options.argv.v) {
    console.log(coffeelint.VERSION);
    process.exit(0);
  } else if (options.argv.h) {
    options.showHelp();
    process.exit(0);
  } else if (options.argv.makeconfig) {
    console.log(JSON.stringify(coffeelint.RULES, (function(k, v) {
      if (k !== 'message' && k !== 'description') {
        return v;
      }
    }), 4));
  } else if (options.argv._.length < 1 && !options.argv.s) {
    options.showHelp();
    process.exit(1);
  } else {
    config = {};
    if (!options.argv.noconfig) {
      existsFn = (ref = fs.existsSync) != null ? ref : path.existsSync;
      if (options.argv.f) {
        config = JSON.parse(read(options.argv.f));
      } else if (process.env.COFFEELINT_CONFIG && existsFn(process.env.COFFEELINT_CONFIG)) {
        config = JSON.parse(read(process.env.COFFEELINT_CONFIG));
      }
    }
    if (options.argv.s) {
      data = '';
      stdin = process.openStdin();
      stdin.on('data', function(buffer) {
        if (buffer) {
          return data += buffer.toString();
        }
      });
      stdin.on('end', function() {
        var errorReport;
        errorReport = lintSource(data, config, options.argv.literate);
        return reportAndExit(errorReport, options);
      });
    } else {
      paths = options.argv._;
      scripts = options.argv.r ? findCoffeeScripts(paths) : paths;
      errorReport = lintFiles(scripts, config, options.argv.literate);
      reportAndExit(errorReport, options);
    }
  }

}).call(this);
